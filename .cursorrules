# TRADERSUTOPIA Cursor Rules

# These rules MUST be automatically followed for ALL prompts and development tasks

## ğŸš« CRITICAL RESTRICTIONS

### 1. NO GIT OPERATIONS

- NEVER suggest, execute, or perform any git operations (git add, git commit, git push, git pull, git merge, etc.)
- NEVER create or modify git-related files (.gitignore, .gitattributes)
- NEVER suggest git workflows or branching strategies
- Focus solely on code implementation and file modifications

## ğŸ—ï¸ ARCHITECTURE & STACK

### Core Technologies

- **Framework**: Next.js 14+ (App Router)
- **Language**: TypeScript (strict mode)
- **Database**: PostgreSQL with Prisma ORM (Neon hosting)
- **Authentication**: Clerk
- **Payments**: Stripe
- **Deployment**: AWS Amplify
- **Styling**: Tailwind CSS + shadcn/ui components
- **Package Manager**: pnpm (preferred)

### Key Features

- Real-time chat/messaging system
- Subscription-based access control
- Two-factor authentication (2FA)
- Admin panel with user management
- Server/channel organization (Discord-like)
- File uploads with security validation
- CSRF protection
- Rate limiting
- Push notifications

## ğŸ“ PROJECT STRUCTURE

### Directory Organization

```
src/
â”œâ”€â”€ app/                    # Next.js App Router pages
â”‚   â”œâ”€â”€ (auth)/            # Authentication routes
â”‚   â”œâ”€â”€ (main)/            # Main application routes
â”‚   â””â”€â”€ api/               # API routes
â”œâ”€â”€ components/            # React components
â”‚   â”œâ”€â”€ ui/               # shadcn/ui components
â”‚   â”œâ”€â”€ modals/           # Modal components
â”‚   â”œâ”€â”€ chat/             # Chat-related components
â”‚   â””â”€â”€ [feature]/        # Feature-specific components
â”œâ”€â”€ lib/                   # Utility libraries
â”œâ”€â”€ hooks/                 # Custom React hooks
â”œâ”€â”€ contexts/              # React contexts
â”œâ”€â”€ store/                 # State management (Zustand)
â””â”€â”€ types/                 # TypeScript type definitions
```

## ğŸ”’ SECURITY REQUIREMENTS

### Must Always Implement

- **Input Validation**: Use Zod schemas for all user inputs
- **CSRF Protection**: Include CSRF tokens for state-changing operations
- **Rate Limiting**: Apply to all API endpoints
- **Authentication**: Verify user sessions before sensitive operations
- **Authorization**: Check user permissions and subscription status
- **SQL Injection Prevention**: Use Prisma ORM properly
- **File Upload Security**: Validate file types and sizes
- **Environment Variables**: Never expose sensitive keys in client code

### Security Patterns

```typescript
// Example: Always validate inputs
const schema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
});

// Example: Always check authentication
const { userId } = auth();
if (!userId) {
  return new NextResponse('Unauthorized', { status: 401 });
}
```

## ğŸ’³ SUBSCRIPTION SYSTEM

### Access Control Logic

- **Free users**: Limited access to basic features
- **Trial users**: Full access for limited time
- **Paid subscribers**: Full access to all features
- **Admin users**: Management capabilities

### Implementation Pattern

```typescript
// Always check subscription status for protected features
const subscription = await getCurrentSubscription(userId);
if (!subscription?.isActive) {
  return redirect('/pricing');
}
```

## ğŸ¨ UI/UX GUIDELINES

### Component Standards

- Use shadcn/ui components as base
- Implement responsive design (mobile-first)
- Follow consistent spacing using Tailwind classes
- Use proper loading states and error handling
- Implement accessibility features (ARIA labels, keyboard navigation)

### Styling Conventions

```typescript
// Example: Consistent button styling
<Button
  variant="default"
  size="sm"
  className="w-full md:w-auto"
  disabled={isLoading}
>
  {isLoading && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
  Submit
</Button>
```

## ğŸ› ï¸ DEVELOPMENT PRACTICES

### Code Quality

- **TypeScript**: Use strict typing, avoid `any`
- **Error Handling**: Implement proper try-catch blocks
- **Loading States**: Show loading indicators for async operations
- **Validation**: Client-side validation + server-side validation
- **Performance**: Optimize with React.memo, useMemo, useCallback when needed

### Architecture Communication Patterns

- **API Routes**: Must use the centralized database and stripe services from `src/services/` for all server communication
- **UI Components**: Must communicate with the server exclusively through API routes (no direct service calls)
- **Service Layer**: Database and Stripe services act as the single source of truth for server operations
- **Data Flow**: UI â†’ API Routes â†’ Services â†’ Database/Stripe â†’ Services â†’ API Routes â†’ UI

### API Route Standards

```typescript
// Standard API route structure using centralized services
import { DatabaseService } from '@/services/database';
import { StripeService } from '@/services/stripe';

export async function POST(req: Request) {
  try {
    // 1. Rate limiting
    const rateLimitResult = await rateLimit(req);
    if (!rateLimitResult.success) {
      return new NextResponse('Rate limit exceeded', { status: 429 });
    }

    // 2. Authentication
    const { userId } = auth();
    if (!userId) {
      return new NextResponse('Unauthorized', { status: 401 });
    }

    // 3. Input validation
    const body = await req.json();
    const validatedData = schema.parse(body);

    // 4. Business logic using centralized services
    const dbService = new DatabaseService();
    const stripeService = new StripeService();

    const result = await dbService.performDatabaseOperation(validatedData);
    // or const result = await stripeService.performStripeOperation(validatedData);

    return NextResponse.json(result);
  } catch (error) {
    console.error('API Error:', error);
    return new NextResponse('Internal Server Error', { status: 500 });
  }
}
```

### Database Operations

- **MANDATORY**: Use centralized database services from `src/services/database/`
- API routes must instantiate and use DatabaseService classes
- Use Prisma transactions for multi-table operations through service methods
- Implement proper error handling in service layer
- Use select statements to limit returned fields
- Include proper indexes for performance

### Stripe Operations

- **MANDATORY**: Use centralized stripe services from `src/services/stripe/`
- API routes must instantiate and use StripeService classes
- All payment processing must go through service layer
- Subscription management through SubscriptionService
- Customer operations through CustomerService
- Invoice handling through InvoiceService

## ğŸ”„ STATE MANAGEMENT

### Zustand Store Pattern

```typescript
// Use Zustand for global state
interface StoreState {
  data: SomeType[];
  isLoading: boolean;
  error: string | null;
}

interface StoreActions {
  fetchData: () => Promise<void>;
  updateData: (data: SomeType) => void;
  reset: () => void;
}
```

## ğŸ“± RESPONSIVE DESIGN

### Breakpoint Strategy

- **Mobile**: Base styles (default)
- **Tablet**: md: prefix (768px+)
- **Desktop**: lg: prefix (1024px+)
- **Large Desktop**: xl: prefix (1280px+)

## ğŸš€ DEPLOYMENT CONSIDERATIONS

### AWS Amplify Compatibility

- Ensure all environment variables are properly configured
- Use Next.js static optimization where possible
- Implement proper error boundaries
- Test build process locally before deployment

## ğŸ“‹ TESTING REQUIREMENTS

### When Adding New Features

- Test authentication flows
- Verify subscription access controls
- Test responsive design on multiple devices
- Validate form inputs and error states
- Check API rate limiting

## ğŸ”§ ENVIRONMENT VARIABLES

### Required Variables (always verify presence)

- `DATABASE_URL`
- `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`
- `CLERK_SECRET_KEY`
- `STRIPE_API_KEY`
- `STRIPE_WEBHOOK_SECRET`
- `UPLOADTHING_SECRET`
- `UPLOADTHING_APP_ID`

## ğŸ“ API INTEGRATION PATTERNS

### External Services

- **Clerk**: User authentication and management
- **Stripe**: Payment processing and subscription management
- **Neon**: PostgreSQL database hosting
- **UploadThing**: File upload handling

### Error Handling Pattern

```typescript
// Consistent error response format
if (error instanceof z.ZodError) {
  return new NextResponse('Invalid input', { status: 400 });
}

if (error instanceof Prisma.PrismaClientKnownRequestError) {
  return new NextResponse('Database error', { status: 500 });
}

return new NextResponse('Internal server error', { status: 500 });
```

---

## ğŸ¯ AUTOMATIC COMPLIANCE

**These rules MUST be automatically followed for ALL prompts. When implementing any feature or fixing any issue:**

1. âœ… NO git operations whatsoever
2. âœ… Implement proper security measures
3. âœ… Follow TypeScript best practices
4. âœ… Use established component patterns
5. âœ… Include proper error handling
6. âœ… Verify authentication and authorization
7. âœ… Test subscription access controls
8. âœ… Ensure responsive design
9. âœ… Validate all inputs
10. âœ… Follow the established project structure

**Remember: These rules apply to EVERY interaction and code modification.**
