generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Core User Model - Clean separation from subscription data
model User {
  id                             String                          @id @default(cuid()) // Clerk user ID (no default, manually set)
  email                          String                          @unique
  name                           String
  imageUrl                       String?
  isAdmin                        Boolean                         @default(false) // Only admins can send messages
  createdAt                      DateTime                        @default(now())
  updatedAt                      DateTime                        @updatedAt
  
  // Relationships
  subscription                   Subscription?
  members                        Member[]
  servers                        Server[]
  channels                       Channel[]                       // Channels created by user
  sections                       Section[]                       // Sections created by user
  roles                          Role[]                          // Roles created by user (admin only)
  channelNotificationPreferences ChannelNotificationPreference[]
  notifications                  Notification[]
  pushSubscriptions              PushSubscription[]
  customDiscountOffers           CustomDiscountOffer[]

  @@map("users")
}

// Simplified Subscription Model - Essential fields for access control
model Subscription {
  id                   String             @id @default(cuid())
  userId               String             @unique
  
  // Core Stripe integration
  stripeSubscriptionId String             @unique
  stripeCustomerId     String
  
  // Access control fields
  status               SubscriptionStatus @default(FREE)
  currentPeriodEnd     DateTime?          // For grace period calculations
  
  // Timestamps
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

// Push Notification Subscriptions
model PushSubscription {
  id           String    @id @default(cuid())
  userId       String
  endpoint     String    @unique
  keys         Json      // p256dh and auth keys
  deviceInfo   Json?     // Browser, OS, device type information
  lastActive   DateTime  @default(now())
  failureCount Int       @default(0)
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
  @@index([lastActive])
  @@index([failureCount])
  @@map("push_subscriptions")
}

// Server Model
model Server {
  id         String    @id @default(cuid())
  name       String
  imageUrl   String?
  inviteCode String    @unique
  ownerId    String    // Must be an admin
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  
  owner      User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  members    Member[]
  roles      Role[]
  sections   Section[]
  channels   Channel[]

  @@index([ownerId])
  @@map("servers")
}

// Simplified Role System - Currently premium/free, but extensible
model Role {
  id          String   @id @default(cuid())
  name        String   // e.g., "premium", "free", future: "vip", "basic", etc.
  color       String?  // Hex color for role display
  serverId    String
  creatorId   String   // Admin who created this role
  isDefault   Boolean  @default(false) // Default role for new members (usually "free")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  server      Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)
  creator     User     @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  members     Member[] // Members with this role
  
  // Access control - which channels/sections this role can access
  channelAccess RoleChannelAccess[]
  sectionAccess RoleSectionAccess[]

  @@index([serverId])
  @@index([creatorId])
  @@map("roles")
}

// Which channels a role can access
model RoleChannelAccess {
  id        String   @id @default(cuid())
  roleId    String
  channelId String
  createdAt DateTime @default(now())
  
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  channel   Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([roleId, channelId])
  @@map("role_channel_access")
}

// Which sections a role can access
model RoleSectionAccess {
  id        String   @id @default(cuid())
  roleId    String
  sectionId String
  createdAt DateTime @default(now())
  
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  section   Section  @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@unique([roleId, sectionId])
  @@map("role_section_access")
}

// Member Model - User's membership in a server
model Member {
  id        String   @id @default(cuid())
  userId    String
  serverId  String
  roleId    String   // Current role (premium/free)
  nickname  String?  // Server-specific nickname
  joinedAt  DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  server    Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  messages  Message[]

  @@unique([userId, serverId])
  @@index([userId])
  @@index([serverId])
  @@index([roleId])
  @@map("members")
}

// Section Model (Channel Categories)
model Section {
  id          String    @id @default(cuid())
  name        String
  serverId    String
  creatorId   String
  parentId    String?   // For nested sections
  position    Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  server      Server    @relation(fields: [serverId], references: [id], onDelete: Cascade)
  creator     User      @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  parent      Section?  @relation("SectionHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children    Section[] @relation("SectionHierarchy")
  channels    Channel[]
  roleAccess  RoleSectionAccess[]

  @@index([serverId])
  @@index([creatorId])
  @@index([parentId])
  @@index([position])
  @@map("sections")
}

// Channel Model
model Channel {
  id          String      @id @default(cuid())
  name        String
  type        ChannelType @default(TEXT)
  topic       String?     // Channel description/topic
  serverId    String
  sectionId   String?
  creatorId   String      // Admin who created the channel
  position    Int         @default(0)
  isTrackRecord Boolean   @default(false) // Mark if this is the track record channel
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  server      Server      @relation(fields: [serverId], references: [id], onDelete: Cascade)
  section     Section?    @relation(fields: [sectionId], references: [id], onDelete: SetNull)
  creator     User        @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  messages    Message[]
  roleAccess  RoleChannelAccess[]
  notificationPreferences ChannelNotificationPreference[]

  @@index([serverId])
  @@index([sectionId])
  @@index([creatorId])
  @@index([position])
  @@index([isTrackRecord])
  @@map("channels")
}

// Message Model - Only admins can send messages
model Message {
  id          String       @id @default(cuid())
  content     String
  channelId   String
  memberId    String       // Must be an admin member
  deleted     Boolean      @default(false)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  
  channel     Channel      @relation(fields: [channelId], references: [id], onDelete: Cascade)
  member      Member       @relation(fields: [memberId], references: [id], onDelete: Cascade)
  attachments Attachment[] // Multiple attachments per message

  @@index([channelId])
  @@index([memberId])
  @@index([createdAt])
  @@map("messages")
}

// Attachment Model - CDN/S3 optimized file storage
model Attachment {
  id          String   @id @default(cuid())
  messageId   String
  filename    String   // Original filename
  url         String   // CDN/S3 URL
  cdnUrl      String?  // Optimized CDN URL (for images with transformations)
  thumbnailUrl String? // Thumbnail URL for images/videos
  fileType    String   // MIME type (image/png, video/mp4, etc.)
  fileSize    Int      // File size in bytes
  width       Int?     // Image/video width
  height      Int?     // Image/video height
  duration    Int?     // Video/audio duration in seconds
  uploadKey   String?  // S3 key or storage identifier
  metadata    Json?    // Additional metadata (alt text, description, etc.)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([fileType])
  @@index([createdAt])
  @@map("attachments")
}

// Enhanced Notification System - Supports subscription updates
model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  read      Boolean          @default(false)
  actionUrl String?
  metadata  Json?            // Additional data (subscription info, discount details, etc.)
  createdAt DateTime         @default(now())
  
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([read])
  @@index([type])
  @@index([createdAt])
  @@map("notifications")
}

// Channel-specific notification preferences
model ChannelNotificationPreference {
  id        String   @id @default(cuid())
  userId    String
  channelId String
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel   Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
  @@index([userId])
  @@index([channelId])
  @@map("channel_notification_preferences")
}

model Timer {
  id           String   @id @default(cuid())
  startTime    DateTime 
  duration     Int      // Duration in hours
  message      String   
  priceMessage String
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("timers")
}

// Custom Discount Offers - Generated when users decline initial discount offers
model CustomDiscountOffer {
  id                  String    @id @default(cuid())
  userId              String
  subscriptionId      String
  originalPriceCents  Int       // Original subscription price in cents
  userInputCents      Int       // User's comfortable price in cents  
  offerPriceCents     Int       // Generated offer price in cents
  discountPercent     Float     // Percentage discount (5-10%)
  savingsCents        Int       // Amount saved in cents
  expiresAt           DateTime  // 2 days from creation
  isExpired           Boolean   @default(false)
  acceptedAt          DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, subscriptionId]) // Only one active offer per user/subscription
  @@index([userId])
  @@index([expiresAt])
  @@index([isExpired])
  @@map("custom_discount_offers")
}

// Enums
enum ChannelType {
  TEXT
  ANNOUNCEMENT
}

enum SubscriptionStatus {
  FREE              // Custom status for users with no Stripe subscription
  INCOMPLETE        // Stripe: incomplete
  INCOMPLETE_EXPIRED // Stripe: incomplete_expired
  TRIALING          // Stripe: trialing
  ACTIVE            // Stripe: active
  PAST_DUE          // Stripe: past_due
  CANCELED          // Stripe: canceled
  UNPAID            // Stripe: unpaid
  PAUSED            // Stripe: paused
}

enum NotificationType {
  NEW_MESSAGE        // New message in subscribed channel
  ADMIN_ANNOUNCEMENT // Admin announcement
  SUBSCRIPTION_CANCELLED
  SUBSCRIPTION_RENEWED
  SUBSCRIPTION_PAST_DUE
  DISCOUNT_APPLIED
  PAYMENT_FAILED
  TRIAL_ENDING
  SYSTEM
}
