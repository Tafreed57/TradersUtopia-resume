generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Core User Model - Clean separation from subscription data
model User {
  id                             String                          @id @default(cuid())
  userId                        String                          @unique // Clerk user ID
  email                          String                          @unique
  name                           String
  imageUrl                       String?
  isAdmin                        Boolean                         @default(false) // Only admins can send messages
  createdAt                      DateTime                        @default(now())
  updatedAt                      DateTime                        @updatedAt
  
  // Relationships
  subscription                   Subscription?
  members                        Member[]
  servers                        Server[]
  channels                       Channel[]                       // Channels created by user
  sections                       Section[]                       // Sections created by user
  roles                          Role[]                          // Roles created by user (admin only)
  channelNotificationPreferences ChannelNotificationPreference[]
  notifications                  Notification[]
  pushSubscriptions              PushSubscription[]

  @@map("users")
}

// Stripe Subscription Management - Single source of truth
model Subscription {
  id                      String             @id @default(cuid())
  userId                  String             @unique
  
  // Core Stripe fields
  stripeSubscriptionId    String             @unique
  stripeCustomerId        String
  status                  SubscriptionStatus @default(FREE)
  currency                String             @default("usd")
  created                 DateTime           // Stripe creation timestamp
  currentPeriodStart      DateTime?
  currentPeriodEnd        DateTime?
  startDate               DateTime?
  
  // Cancellation fields
  cancelAt                DateTime?
  cancelAtPeriodEnd       Boolean            @default(false)
  canceledAt              DateTime?
  endedAt                 DateTime?
  
  // Trial fields
  trialStart              DateTime?
  trialEnd                DateTime?
  
  // Payment and billing
  defaultPaymentMethod    String?
  latestInvoice           String?
  collectionMethod        String?            @default("charge_automatically")
  
  // Subscription items and pricing
  items                   Json?              // Stripe subscription items
  
  // Additional Stripe fields
  automaticTax            Json?              // Stripe automatic tax settings
  billingCycleAnchor      DateTime?
  description             String?
  metadata                Json?              // Stripe metadata
  pendingSetupIntent      String?
  pendingUpdate           Json?              // Stripe pending update object
  
  // Our custom fields for business logic
  discountPercent         Int?
  discountName            String?
  lastInvoiceUrl          String?
  
  // Timestamps
  createdAt               DateTime           @default(now())
  updatedAt               DateTime           @updatedAt
  
  user                    User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

// Push Notification Subscriptions
model PushSubscription {
  id       String @id @default(cuid())
  userId   String
  endpoint String @unique
  keys     Json   // p256dh and auth keys
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("push_subscriptions")
}

// Server Model
model Server {
  id         String    @id @default(cuid())
  name       String
  imageUrl   String?
  inviteCode String    @unique
  ownerId    String    // Must be an admin
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  
  owner      User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  members    Member[]
  roles      Role[]
  sections   Section[]
  channels   Channel[]

  @@index([ownerId])
  @@map("servers")
}

// Simplified Role System - Currently premium/free, but extensible
model Role {
  id          String   @id @default(cuid())
  name        String   // e.g., "premium", "free", future: "vip", "basic", etc.
  color       String?  // Hex color for role display
  serverId    String
  creatorId   String   // Admin who created this role
  isDefault   Boolean  @default(false) // Default role for new members (usually "free")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  server      Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)
  creator     User     @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  members     Member[] // Members with this role
  
  // Access control - which channels/sections this role can access
  channelAccess RoleChannelAccess[]
  sectionAccess RoleSectionAccess[]

  @@index([serverId])
  @@index([creatorId])
  @@map("roles")
}

// Which channels a role can access
model RoleChannelAccess {
  id        String   @id @default(cuid())
  roleId    String
  channelId String
  createdAt DateTime @default(now())
  
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  channel   Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([roleId, channelId])
  @@map("role_channel_access")
}

// Which sections a role can access
model RoleSectionAccess {
  id        String   @id @default(cuid())
  roleId    String
  sectionId String
  createdAt DateTime @default(now())
  
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  section   Section  @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@unique([roleId, sectionId])
  @@map("role_section_access")
}

// Member Model - User's membership in a server
model Member {
  id        String   @id @default(cuid())
  userId    String
  serverId  String
  roleId    String   // Current role (premium/free)
  nickname  String?  // Server-specific nickname
  joinedAt  DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  server    Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  messages  Message[]

  @@unique([userId, serverId])
  @@index([userId])
  @@index([serverId])
  @@index([roleId])
  @@map("members")
}

// Section Model (Channel Categories)
model Section {
  id          String    @id @default(cuid())
  name        String
  serverId    String
  creatorId   String
  parentId    String?   // For nested sections
  position    Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  server      Server    @relation(fields: [serverId], references: [id], onDelete: Cascade)
  creator     User      @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  parent      Section?  @relation("SectionHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children    Section[] @relation("SectionHierarchy")
  channels    Channel[]
  roleAccess  RoleSectionAccess[]

  @@index([serverId])
  @@index([creatorId])
  @@index([parentId])
  @@index([position])
  @@map("sections")
}

// Channel Model
model Channel {
  id          String      @id @default(cuid())
  name        String
  type        ChannelType @default(TEXT)
  topic       String?     // Channel description/topic
  serverId    String
  sectionId   String?
  creatorId   String      // Admin who created the channel
  position    Int         @default(0)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  server      Server      @relation(fields: [serverId], references: [id], onDelete: Cascade)
  section     Section?    @relation(fields: [sectionId], references: [id], onDelete: SetNull)
  creator     User        @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  messages    Message[]
  roleAccess  RoleChannelAccess[]
  notificationPreferences ChannelNotificationPreference[]

  @@index([serverId])
  @@index([sectionId])
  @@index([creatorId])
  @@index([position])
  @@map("channels")
}

// Message Model - Only admins can send messages
model Message {
  id          String       @id @default(cuid())
  content     String
  channelId   String
  memberId    String       // Must be an admin member
  deleted     Boolean      @default(false)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  
  channel     Channel      @relation(fields: [channelId], references: [id], onDelete: Cascade)
  member      Member       @relation(fields: [memberId], references: [id], onDelete: Cascade)
  attachments Attachment[] // Multiple attachments per message

  @@index([channelId])
  @@index([memberId])
  @@index([createdAt])
  @@map("messages")
}

// Attachment Model - CDN/S3 optimized file storage
model Attachment {
  id          String   @id @default(cuid())
  messageId   String
  filename    String   // Original filename
  url         String   // CDN/S3 URL
  cdnUrl      String?  // Optimized CDN URL (for images with transformations)
  thumbnailUrl String? // Thumbnail URL for images/videos
  fileType    String   // MIME type (image/png, video/mp4, etc.)
  fileSize    Int      // File size in bytes
  width       Int?     // Image/video width
  height      Int?     // Image/video height
  duration    Int?     // Video/audio duration in seconds
  uploadKey   String?  // S3 key or storage identifier
  metadata    Json?    // Additional metadata (alt text, description, etc.)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([fileType])
  @@index([createdAt])
  @@map("attachments")
}

// Enhanced Notification System - Supports subscription updates
model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  read      Boolean          @default(false)
  actionUrl String?
  metadata  Json?            // Additional data (subscription info, discount details, etc.)
  createdAt DateTime         @default(now())
  
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([read])
  @@index([type])
  @@index([createdAt])
  @@map("notifications")
}

// Channel-specific notification preferences
model ChannelNotificationPreference {
  id        String   @id @default(cuid())
  userId    String
  channelId String
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel   Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
  @@index([userId])
  @@index([channelId])
  @@map("channel_notification_preferences")
}

model Timer {
  id           String   @id @default(cuid())
  startTime    DateTime 
  duration     Int      // Duration in hours
  message      String   
  priceMessage String
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("timers")
}

// Enums
enum ChannelType {
  TEXT
  ANNOUNCEMENT
}

enum SubscriptionStatus {
  FREE              // Custom status for users with no Stripe subscription
  INCOMPLETE        // Stripe: incomplete
  INCOMPLETE_EXPIRED // Stripe: incomplete_expired
  TRIALING          // Stripe: trialing
  ACTIVE            // Stripe: active
  PAST_DUE          // Stripe: past_due
  CANCELED          // Stripe: canceled
  UNPAID            // Stripe: unpaid
  PAUSED            // Stripe: paused
}

enum NotificationType {
  NEW_MESSAGE        // New message in subscribed channel
  ADMIN_ANNOUNCEMENT // Admin announcement
  SUBSCRIPTION_CANCELLED
  SUBSCRIPTION_RENEWED
  SUBSCRIPTION_PAST_DUE
  DISCOUNT_APPLIED
  PAYMENT_FAILED
  TRIAL_ENDING
  SYSTEM
}
